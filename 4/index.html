<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CS180 Project 3 Report</title>
  <script>
    window.MathJax = {
      tex: { inlineMath: [['\\(','\\)'], ['$', '$']], displayMath: [['\\[','\\]'], ['$$','$$']] }
    };
  </script>
  <script async id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    :root { --border:#ddd; --muted:#666; --accent:#0b6cff; --bg:#fff; }
    *{box-sizing:border-box}
    body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Inter,Helvetica,Arial,sans-serif;margin:24px;color:#111;background:var(--bg);line-height:1.55}
    header{margin-bottom:18px}
    h1{margin:0 0 8px;font-size:28px}
    h2{margin-top:36px;padding-top:8px;border-top:2px solid var(--border);font-size:22px}
    h3{margin-top:20px;font-size:18px;color:#222}
    p.note{color:var(--muted);font-size:14px;margin:6px 0 18px}
    nav{position:sticky;top:0;background:var(--bg);padding:10px 0;margin-bottom:12px;border-bottom:1px solid var(--border)}
    nav .toc{display:flex;flex-wrap:wrap;gap:10px 14px;font-size:14px}
    nav a{color:var(--accent);text-decoration:none}
    nav a:hover{text-decoration:underline}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;margin:12px 0 22px}
    .pair{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px;margin:12px 0 22px}
    figure{margin:0;padding:10px;border:1px dashed var(--border);border-radius:8px;display:flex;flex-direction:column;align-items:center;gap:8px;background:#fff}
    img{max-width:100%;height:auto;display:block}
    figcaption{font-size:13px;color:#333;text-align:center}
    .caption{font-size:13px;color:#333;margin-top:6px}
    .small{font-size:12px;color:var(--muted)}
    code{background:#f5f5f5;padding:2px 6px;border-radius:4px}
    pre{background:#f8f8f8;border:1px solid var(--border);border-radius:8px;padding:12px;overflow:auto;font-size:13px;line-height:1.45}
    table{width:100%;border-collapse:collapse;margin:14px 0 22px;table-layout:fixed}
    th,td{border:1px solid var(--border);padding:10px;text-align:center;vertical-align:top}
    th{background:#fafafa;font-weight:600}
    .back-home{position:fixed;top:12px;right:12px;z-index:1000;display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;border:1px solid var(--border);background:#fff;color:#111;text-decoration:none;font-size:14px;box-shadow:0 1px 3px rgba(0,0,0,0.06);transition:transform 0.06s ease,box-shadow 0.2s ease,background 0.2s ease}
    .back-home:hover{transform:translateY(-1px);box-shadow:0 4px 10px rgba(0,0,0,0.08)}
    .back-home:active{transform:translateY(0)}
    .back-home svg{width:16px;height:16px}
    .legend{display:flex;align-items:center;gap:10px;font-size:13px;color:#333;margin:6px 0}
    .swatch{width:12px;height:12px;border-radius:50%;display:inline-block}
    .green{background:#00a651}
    .red{background:#e11d48}
    
  </style>
</head>
<body>

  <a class="back-home" href="../index.html" title="Back to Home">
    <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
      <path d="M15 6l-6 6 6 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    Back to Home
  </a>

  <header>
    <h1>CS180 Project 3</h1>
    <p class="note">Author: Maanit Sharma</p>
  </header>

  <nav>
    <div class="toc">
      <a href="#a1">A.1 Shoot & Digitize</a>
      <a href="#a2">A.2 Recover Homographies</a>
      <a href="#a3">A.3 Warp & Rectify</a>
      <a href="#a4">A.4 Blend into Mosaic</a>
      
      <a href="#b1">B.1 Harris Corner Detection</a>
      <a href="#b2">B.2 Feature Descriptor Extraction</a>
      <a href="#b3">B.3 Feature Matching</a>
      <a href="#b4">B.4: RANSAC for Robust Homography</a>
    </div>
  </nav>

  <!-- A.1 -->
  <section id="a1">
    <h2>A.1: Shoot and Digitize Pictures</h2>
    <p>Two pairs were captured by rotating the camera about (approximately) the same center of projection: Physics Building and Doe Library.</p>
    <div class="grid">
      <figure>
        <img src="./media/physics_left.jpg" alt="Physics building - first view">
        <figcaption>Physics Building — first image</figcaption>
      </figure>
      <figure>
        <img src="./media/physics_right.jpg" alt="Physics building - second rotated view">
        <figcaption>Physics Building — second image (rotated)</figcaption>
      </figure>
      <figure>
        <img src="./media/doe_left.jpg" alt="Doe Library - first view">
        <figcaption>Doe Library — first image</figcaption>
      </figure>
      <figure>
        <img src="./media/doe_right.jpg" alt="Doe Library - second rotated view">
        <figcaption>Doe Library — second image (rotated)</figcaption>
      </figure>
    </div>
  </section>

  <!-- A.2 -->
  <section id="a2">
    <h2>A.2: Recover Homographies</h2>
    <p><strong>Method.</strong> For each correspondence (x1, y1) to (u, v) and fixing h_33 = 1, I assemble the least-squares system Ah = b:</p>
    <pre><code>[x y 1  0 0 0  -u x  -u y] · h = u
[0 0 0  x y 1  -v x  -v y] · h = v
</code></pre>
    <p>Stacking all pairs and solving \(\min\lVert A\mathbf{h}-\mathbf{b}\rVert_2\) gives \(H\):</p>
    <pre><code>H = [[h11 h12 h13],
     [h21 h22 h23],
     [h31 h32   1]]</code></pre>
    

    <h3 class="small">Normalized DLT (SVD) & RANSAC</h3>
    <p class="small">
      In addition to the least-squares fit with h_33=1, I estimate H using
      <strong>Normalized DLT</strong> solved by <strong>SVD</strong>.
      I first apply Hartley normalization to both point sets (\(\tilde{\mathbf{x}}=T_1\mathbf{x}\),
      \(\tilde{\mathbf{x}}'=T_2\mathbf{x}'\)), stack the homogeneous system
      \(A\tilde{\mathbf{h}}=\mathbf{0}\) (2 rows per match), and take \(\tilde{\mathbf{h}}\) as the
      right singular vector corresponding to the smallest singular value of \(A\).
      The final homography is \(H = T_2^{-1}\,\tilde{H}\,T_1\) and is scaled so \(H_{33}=1\).
    </p>
    
    <pre><code># in code: dlt_homography(...)
      1) normalize points          
      2) build 2x9 rows per match
      3) h = last row of V^T (SVD) (vector that satisfies Ah = 0, i.e. in nullspace of A, with smalles singular value)
      4) denormalize and scale
    </code></pre>
    
    <p class="small">
      To be robust to outliers, I use <strong>RANSAC</strong>. Each iteration samples 4 correspondences,
      computes a candidate \(H\) by DLT, evaluates reprojection errors, and marks inliers
      where \(\|\pi(H\,\mathbf{x}_i)-\mathbf{x}'_i\| &lt; \tau\).
      I adapt the number of iterations using the inlier rate \(w\) and target confidence
      \(p\) via \(N \approx \frac{\log(1-p)}{\log(1-w^4)}\). After RANSAC, I
      <em>refit</em> \(H\) using all inliers.
    </p>


    <h3>Point Correspondences</h3>
    <div class="grid">
      <figure>
        <img src="./media/physics_correspondence.jpg" alt="Physics correspondences">
        <figcaption>Physics — correspondences</figcaption>
      </figure>
      <figure>
        <img src="./media/doe_correspondence.jpg" alt="Doe correspondences">
        <figcaption>Doe — correspondences</figcaption>
      </figure>
    </div>
    <div class="legend">
      <span class="swatch green"></span> <span>Inliers</span>
      <span class="swatch red"></span> <span>Outliers</span>
    </div>

    <h3 class="small">Physics — Full Least-Squares System (A, b)</h3>
    <p class="small">
      Least-squares setup with <code>h<sub>33</sub>=1</code> (8 unknowns). Two rows per correspondence → <code>A ∈ ℝ^{56×8}</code>, <code>b ∈ ℝ^{56}</code>.
    </p>
    
    <details>
      <summary><strong>Show A<sub>physics</sub> (56×8)</strong></summary>
      <pre><code>A_physics = [[ 3.2150000e+03  3.1600000e+02  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -8.4554500e+06 -8.3108000e+05]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  3.2150000e+03
       3.1600000e+02  1.0000000e+00 -1.0448750e+06 -1.0270000e+05]
     [ 1.4620000e+03  1.6990000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -9.1375000e+05 -1.0618750e+06]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  1.4620000e+03
       1.6990000e+03  1.0000000e+00 -2.2105440e+06 -2.5688880e+06]
     [ 3.1340000e+03  3.8060000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -7.1329840e+06 -8.6624560e+06]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  3.1340000e+03
       3.8060000e+03  1.0000000e+00 -1.1928004e+07 -1.4485636e+07]
     [ 1.7410000e+03  3.1620000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -1.4258790e+06 -2.5896780e+06]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  1.7410000e+03
       3.1620000e+03  1.0000000e+00 -5.4127690e+06 -9.8306580e+06]
     [ 3.2240000e+03  4.3500000e+02  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -8.4758960e+06 -1.1436150e+06]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  3.2240000e+03
       4.3500000e+02  1.0000000e+00 -1.4314560e+06 -1.9314000e+05]
     [ 3.7180000e+03  1.0130000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -1.1403106e+07 -3.1068710e+06]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  3.7180000e+03
       1.0130000e+03  1.0000000e+00 -4.0563380e+06 -1.1051830e+06]
     [ 3.4700000e+03  8.7800000e+02  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -9.8513300e+06 -2.4926420e+06]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  3.4700000e+03
       8.7800000e+02  1.0000000e+00 -3.1924000e+06 -8.0776000e+05]
     [ 3.2520000e+03  7.5400000e+02  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -8.5625160e+06 -1.9852820e+06]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  3.2520000e+03
       7.5400000e+02  1.0000000e+00 -2.4910320e+06 -5.7756400e+05]
     [ 3.0690000e+03  9.3700000e+02  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -7.4852910e+06 -2.2853430e+06]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  3.0690000e+03
       9.3700000e+02  1.0000000e+00 -2.8234800e+06 -8.6204000e+05]
     [ 2.8740000e+03  1.1250000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -6.4003980e+06 -2.5053750e+06]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  2.8740000e+03
       1.1250000e+03  1.0000000e+00 -3.1067940e+06 -1.2161250e+06]
     [ 2.9070000e+03  1.1420000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -6.5756340e+06 -2.5832040e+06]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  2.9070000e+03
       1.1420000e+03  1.0000000e+00 -3.2064210e+06 -1.2596260e+06]
     [ 1.1130000e+03  1.7160000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -2.3150400e+05 -3.5692800e+05]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  1.1130000e+03
       1.7160000e+03  1.0000000e+00 -1.6561440e+06 -2.5534080e+06]
     [ 1.1190000e+03  1.5940000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -2.5401300e+05 -3.6183800e+05]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  1.1190000e+03
       1.5940000e+03  1.0000000e+00 -1.5196020e+06 -2.1646520e+06]
     [ 2.9580000e+03  3.4070000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -6.3064560e+06 -7.2637240e+06]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  2.9580000e+03
       3.4070000e+03  1.0000000e+00 -1.0063116e+07 -1.1590614e+07]
     [ 2.9390000e+03  3.7370000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -6.1219370e+06 -7.7841710e+06]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  2.9390000e+03
       3.7370000e+03  1.0000000e+00 -1.0985982e+07 -1.3968906e+07]
     [ 2.5470000e+03  3.6700000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -4.2662250e+06 -6.1472500e+06]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  2.5470000e+03
       3.6700000e+03  1.0000000e+00 -9.3322080e+06 -1.3446880e+07]
     [ 2.5930000e+03  3.4960000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -4.5144130e+06 -6.0865360e+06]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  2.5930000e+03
       3.4960000e+03  1.0000000e+00 -9.0417910e+06 -1.2190552e+07]
     [ 4.0890000e+03  1.2610000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -1.3853532e+07 -4.2722680e+06]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  4.0890000e+03
       1.2610000e+03  1.0000000e+00 -5.5896630e+06 -1.7237870e+06]
     [ 3.6820000e+03  1.0410000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -1.1145414e+07 -3.1511070e+06]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  3.6820000e+03
       1.0410000e+03  1.0000000e+00 -4.0833380e+06 -1.1544690e+06]
     [ 4.4340000e+03  1.4540000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -1.6325988e+07 -5.3536280e+06]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  4.4340000e+03
       1.4540000e+03  1.0000000e+00 -7.0278900e+06 -2.3045900e+06]
     [ 4.6250000e+03  1.5120000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -1.7801625e+07 -5.8196880e+06]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  4.6250000e+03
       1.5120000e+03  1.0000000e+00 -7.6682500e+06 -2.5068960e+06]
     [ 1.2290000e+03  1.6180000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -4.3506600e+05 -5.7277200e+05]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  1.2290000e+03
       1.6180000e+03  1.0000000e+00 -1.7144550e+06 -2.2571100e+06]
     [ 1.3640000e+03  1.6540000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -6.9564000e+05 -8.4354000e+05]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  1.3640000e+03
       1.6540000e+03  1.0000000e+00 -1.9832560e+06 -2.4049160e+06]
     [ 4.8270000e+03  3.8740000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -1.8666009e+07 -1.4980758e+07]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  4.8270000e+03
       3.8740000e+03  1.0000000e+00 -1.8709452e+07 -1.5015624e+07]
     [ 4.8110000e+03  3.7850000e+03  1.0000000e+00  0.0000000e+00
       0.0000000e+00  0.0000000e+00 -1.8560838e+07 -1.4602530e+07]
     [ 0.0000000e+00  0.0000000e+00  0.0000000e+00  4.8110000e+03
       3.7850000e+03  1.0000000e+00 -1.8248123e+07 -1.4356505e+07]]</code></pre>
    </details>
    
    <details>
      <summary><strong>Show b<sub>physics</sub> (56×1)</strong></summary>
      <pre><code>b_physics = [2630.  325.  625. 1512. 2276. 3806.  819. 3109. 2629.  444. 3067. 1091.
     2839.  920. 2633.  766. 2439.  920. 2227. 1081. 2262. 1103.  208. 1488.
      227. 1358. 2132. 3402. 2083. 3738. 1675. 3664. 1741. 3487. 3388. 1367.
     3027. 1109. 3682. 1585. 3849. 1658.  354. 1395.  510. 1454. 3867. 3876.
     3858. 3793.]</code></pre>
    </details>
    
    <p class="small">
      Solve <code>min ||A h − b||</code>, then assemble
      <code>H = [[h11 h12 h13],[h21 h22 h23],[h31 h32 1]]</code>.
    </p>


    <h3>Recovered Homography Matrices</h3>
    <div class="pair">
      <div>
        <h3 class="small">Physics Building H</h3>
        <pre><code>[[ 1.29486754e+00 -9.55432839e-02 -1.05974725e+03]
 [ 2.07294260e-01  1.15547820e+00 -6.44322456e+02]
 [ 5.36801520e-05 -3.20075730e-06  1.00000000e+00]]</code></pre>
      </div>
      <div>
        <h3 class="small">Doe Library H</h3>
        <pre><code>[[ 1.33415271e+00  4.81828359e-02 -1.47213595e+03]
 [ 8.66244002e-02  1.20402963e+00 -3.49385887e+02]
 [ 5.58252455e-05  5.50233942e-06  1.00000000e+00]]</code></pre>
      </div>
    </div>
  </section>

  <!-- A.3 -->
  <section id="a3">
    <h2>A.3: Warp the Images</h2>
    <p><strong>Inverse warping.</strong> For each output pixel \(x'\), map back via \(x=H^{-1}x'\) to sample the source. I implemented both interpolation schemes:</p>
    <ul>
      <li><strong>Nearest Neighbor:</strong> round to nearest integer pixel.</li>
      <li><strong>Bilinear:</strong> weighted average of the four neighbors using fractional offsets.</li>
    </ul>
    <p class="small">Canvas size is predicted by forward-projecting source corners through \(H\) and taking the bounding box. Out-of-bounds samples are left zero/transparent.</p>

    <h3>Rectification — Chessboard</h3>
    <div class="grid">
      <figure>
        <img src="./media/chess_board.jpg" alt="Original chessboard">
        <figcaption>Original</figcaption>
      </figure>
      <figure>
        <img src="./media/chess_NNrectification.jpg" alt="Rectified chessboard - Nearest Neighbor Interpolation">
        <figcaption>Rectified — Nearest Neighbor</figcaption>
      </figure>
      <figure>
        <img src="./media/chess_Brectification.jpg" alt="Rectified chessboard - Bilinear Interpolation">
        <figcaption>Rectified — Bilinear</figcaption>
      </figure>
    </div>

    <h3>Rectification — Card Deck</h3>
    <div class="grid">
      <figure>
        <img src="./media/card_deck.jpg" alt="Original cards">
        <figcaption>Original</figcaption>
      </figure>
      <figure>
        <img src="./media/cards_NNrectification.jpg" alt="Rectified cards - Nearest Neighbor Interpolation">
        <figcaption>Rectified — Nearest Neighbor</figcaption>
      </figure>
      <figure>
        <img src="./media/cards_Brectification.jpg" alt="Rectified cards - Bilinear Interpolation">
        <figcaption>Rectified — Bilinear</figcaption>
      </figure>
    </div>

    <h3>Nearest Neighbor vs. Bilinear (Brief)</h3>
    <ul>
      <li><strong>Speed:</strong> NN is fastest; Bilinear is slightly slower.</li>
      <li><strong>Quality:</strong> Bilinear reduces aliasing/jaggies; NN keeps hard edges. </li>
      <li><strong>Detail:</strong> Bilinear can blur very fine texture; NN preserves pixel values exactly.</li>
    </ul>
  </section>

  <!-- A.4 -->
  <section id="a4">
    <h2>A.4: Blend the Images into a Mosaic</h2>
    <h2>A.4: Blend the Images into a Mosaic</h2>
    <p><strong>Procedure.</strong> I compute a global canvas by taking the bbox over the left image and the
    right image warped into the left frame (via \(H_{r\to l}\)). I inverse-warp the right image into the
    canvas, embed the left at its native coordinates, and blend using <strong>masked, normalized feathering</strong>:
    </p>
    
    <pre><code># A: left image on canvas, maskA=1 inside left footprint
    # B: right image warped into canvas, maskB=1 where sampling was valid
    
    wA = soft_alpha_box(maskA)   # smooth falloff toward edges
    wB = soft_alpha_box(maskB)
    W  = wA + wB + ε
    
    I_mosaic = (A * wA[...,None] + B * wB[...,None]) / W[...,None]
    I_mosaic[W &lt; ε] = 0
    </code></pre>
    
    <p class="small">
      <em>Masks.</em> <code>maskB</code> is 1 only where the inverse warp lands inside the right image (no holes).
      <code>maskA</code> is 1 on the left image’s support in the canvas. I soften both with a box/average filter
      (integral-image implementation) and normalize per-pixel to avoid seams and exposure steps.
      This replaces hard overwrite and gives a clean, symmetric blend even with imperfect alignment.
    </p>
    
    <p class="small">
      <em>Why masks?</em> The masks ensure we never average invalid samples, and the soft falloff
      reduces ghosting at boundaries. This also makes multi-image mosaics straightforward:
      accumulate weighted sums and divide by the weight image at the end.
    </p>

    <h3>Example 1 — Physics Building</h3>
    <div class="grid">
      <figure>
        <img src="./media/physics_left.jpg" alt="Physics left">
        <figcaption>Original — left</figcaption>
      </figure>
      <figure>
        <img src="./media/physics_right.jpg" alt="Physics right">
        <figcaption>Original — right</figcaption>
      </figure>
      <figure>
        <img src="./media/physics_mosaic.jpg" alt="Physics mosaic">
        <figcaption>Final mosaic</figcaption>
      </figure>
    </div>

    <h3>Example 2 — Doe Library</h3>
    <div class="grid">
      <figure>
        <img src="./media/doe_left.jpg" alt="Doe left">
        <figcaption>Original — left</figcaption>
      </figure>
      <figure>
        <img src="./media/doe_right.jpg" alt="Doe right">
        <figcaption>Original — right</figcaption>
      </figure>
      <figure>
        <img src="./media/doe_mosaic.jpg" alt="Doe mosaic">
        <figcaption>Final mosaic</figcaption>
      </figure>
    </div>

    <h3>Example 3 — Campanile</h3>
    <div class="grid">
      <figure>
        <img src="./media/camp_left.jpg" alt="Campanile left">
        <figcaption>Original — left</figcaption>
      </figure>
      <figure>
        <img src="./media/camp_right.jpg" alt="Campanile right">
        <figcaption>Original — right</figcaption>
      </figure>
      <figure>
        <img src="./media/camp_mosaic.jpg" alt="Campanile mosaic">
        <figcaption>Final mosaic</figcaption>
      </figure>
    </div>
  </section>

  <section id="b1">
  <h2>B.1: Harris Corner Detection</h2>

  <p>
  I detected the Harris corners in my example images using the skimage.feature library and specifically its functions corner_harris, peak_local_max. 
  After computing the Harris corners and the Harris matrix, I applied <strong>Adaptive Non-Maximal Suppression (ANMS)</strong> to select a uniformly distributed subset of strong corners. 
  My ANMS implementation details: I first discard non-positive responses and sort corners by Harris score descending.
  Then for each corner i (in this order), I compute its suppression radius rᵢ as the squared distance to the
  nearest previously seen corner whose response is &gt; c<sub>robust</sub>·fᵢ. If none exist, rᵢ stays ∞.
  Finally, I select the top N corners with the largest radii. Sorting makes the search “one-way” (each point
  only checks stronger points), which both matches ANMS and simplifies the implementation.
  </p>
    
  <p>Detected Harris corners on the first Physics image, shown without ANMS and with ANMS (n = 1,000, c<sub>robust</sub> = 0.9).</p>
  <div class="pair">
    <figure>
      <img src="./media/physics_harris_corners.jpg" alt="Physics Harris corners without ANMS">
      <figcaption>Harris corners (no ANMS)</figcaption>
    </figure>
    <figure>
      <img src="./media/physics1_anms_corners.jpg" alt="Physics Harris corners with ANMS">
      <figcaption>Harris corners with ANMS (n=1000, c<sub>robust</sub>=0.9)</figcaption>
    </figure>
  </div>
</section>

<section id="b2">
  <h2>B.2: Feature Descriptor Extraction</h2>
  <p>
  For each example image, I first blurred it using a convolution with a Gaussian filter with a sigma value of 2.0.
  Around each ANMS-selected corner, I extracted a 40×40 grayscale patch of the blurred image, and downsampled
  it to an 8×8 descriptor by skipping 5 pixels between each sample from the respective 40x40 blurred patch. 
  Each descriptor was normalized to zero mean and unit variance to make it
  invariant to illumination changes. These descriptors represent local texture around corners for matching.
  </p>

  <p>Normalized 8×8 feature descriptors extracted from the first Physics image.</p>
  <div class="grid">
    <figure>
      <img src="./media/physics1_patches_features_pairs.jpg" alt="Physics 8x8 normalized feature descriptors">
      <figcaption>Extracted 8×8 normalized descriptors (sample visualization)</figcaption>
    </figure>
  </div>
</section>

<section id="b3">
  <h2>B.3: Feature Matching</h2>
  <p> I implemented <strong>feature matching</strong> using the <em>Nearest Neighbor Distance Ratio (NNDR)</em> test. For each feature descriptor from the first image, I compute the squared Euclidean distance to all descriptors in the second image. The two smallest distances (<code>e1</code>, <code>e2</code>) correspond to the best and second-best matches. I then apply the ratio test: if <code>e1 / e2 &lt; threshold</code>, 
  the match is accepted as reliable. This rejects ambiguous matches where the nearest and second-nearest descriptors are similarly close. The result is a set of confident correspondences used for estimating the homography in Part B.4. </p> <pre><code># 
  in code: get_candidate_matches_from_features(...) for each f1 in image1_features: compute squared L2 error to all features in image2 find two nearest neighbors (e1, e2) if (e1 / e2) 
  < threshold: keep match (f1 ↔ f2) </code></pre> <p class="small"> This approach is simple yet effective: it captures only distinct feature correspondences, improving robustness for the later RANSAC stage. 
  </p>
  <p>Matched feature pairs between Physics left and right images.</p>
  <div class="grid">
    <figure>
      <img src="./media/physics_matched_features_visual.jpg" alt="Matched features between Physics image pair">
      <figcaption>Matched features — Physics pair</figcaption>
    </figure>
  </div>
</section>

<section id="b4">
  <h2>B.4: RANSAC for Robust Homography</h2>
  <p> To make the homography estimation robust to outliers from automatic feature matching, I implemented a <strong>4-point RANSAC</strong> algorithm with adaptive iteration control and reprojection error evaluation. Below is a concise summary of my method: </p> <ul> <li><strong>Input:</strong> Candidate feature correspondences obtained from Part B.3.</li> <li><strong>Random Sampling:</strong> Randomly select 4 correspondence pairs per iteration to estimate a candidate homography using the DLT method.</li> <li><strong>Reprojection Error:</strong> <ul> <li>Project all points from image 1 using the candidate <code>H</code>.</li> <li>Compute the Euclidean distance between the projected point and its true correspondence in image 2.</li> <li>Points with error less than <code>τ = 3 px</code> are classified as inliers.</li> </ul> </li> <li><strong>Adaptive Iteration Count:</strong> <ul> <li>Track the inlier ratio <code>w</code> and update the required number of iterations based on confidence <code>p = 0.995</code> using:</li> <li><code>N = log(1 − p) / log(1 − w⁴)</code></li> </ul> </li> <li><strong>Model Selection:</strong> Keep the homography producing the maximum number of inliers.</li> <li><strong>Final Refinement:</strong> Re-estimate <code>H</code> using all inliers to improve accuracy.</li> 
  </ul> <pre><code># in code: ransac_homography(...) while i < max_iters: idx = rng.choice(N, 4, replace=False) H_candidate = dlt_homography(pts1[idx], pts2[idx]) errors = reproj_errors(H_candidate, pts1, pts2) inliers = errors < 
                                                               threshold update best_H if inlier count improves update max_iters using inlier ratio and confidence H_final = dlt_homography(pts1[inliers], pts2[inliers]) </code></pre> 
  <p>
  <p><strong>Automatic
  <p>Inlier matches from 4-point RANSAC (with outliers shown) for the Physics example.</p>
  <div class="grid">
    <figure>
      <img src="./media/physics_B_correspondence.jpg" alt="RANSAC inliers and outliers for Physics">
      <figcaption>RANSAC correspondences — inliers and outliers</figcaption>
    </figure>
  </div>

  <p>Mosaic Generation Pipeline:</strong></p> <ul> <li>Detect Harris corners in both images.</li> <li>
    Apply ANMS to select 1,000 spatially uniform, strong corners.</li> <li>
      Extract 8×8 normalized feature descriptors around each corner.</li> <li>
        Match features using Nearest Neighbor Distance Error Ratio (<code>threshold = 0.5</code>).</li> <li>Estimate a robust <code>H</code> 
          using the 4-point RANSAC algorithm.</li> <li>Warp the right image into the left frame using inverse warping.</li> 
    <li>Blend both images with masked normalized feathering for seamless transitions.</li> </ul> <p class="small"> 
      The reprojection error function ensures only geometrically valid correspondences contribute to the homography. 
      My final mosaics use the same <strong>normalized feathering masks</strong> introduced in Part A.4, enabling smooth blending and artifact-free results even under automatic alignment. 
  </p>
  <h3>Manual vs. Automatic Stitching</h3>
  <p class="small">Manual = Part A mosaics (hand-picked correspondences + RANSAC). Automatic = Part B pipeline (Harris + ANMS + descriptors + matching + RANSAC).</p>

  <!-- Physics comparison -->
  <h3 class="small">Physics Building</h3>
  <div class="pair">
    <figure>
      <img src="./media/physics_mosaic.jpg" alt="Physics mosaic (manual)">
      <figcaption>Manual (Part A)</figcaption>
    </figure>
    <figure>
      <img src="./media/physics_mosaic_B.jpg" alt="Physics mosaic (automatic)">
      <figcaption>Automatic (Part B)</figcaption>
    </figure>
  </div>

  <!-- Doe comparison -->
  <h3 class="small">Doe Library</h3>
  <div class="pair">
    <figure>
      <img src="./media/doe_mosaic.jpg" alt="Doe mosaic (manual)">
      <figcaption>Manual (Part A)</figcaption>
    </figure>
    <figure>
      <img src="./media/doe_B_mosaic.jpg" alt="Doe mosaic (automatic)">
      <figcaption>Automatic (Part B)</figcaption>
    </figure>
  </div>

  <!-- Campanile comparison -->
  <h3 class="small">Campanile</h3>
  <div class="pair">
    <figure>
      <img src="./media/camp_mosaic.jpg" alt="Campanile mosaic (manual)">
      <figcaption>Manual (Part A)</figcaption>
    </figure>
    <figure>
      <img src="./media/camp_B_mosaic.jpg" alt="Campanile mosaic (automatic)">
      <figcaption>Automatic (Part B)</figcaption>
    </figure>
  </div>

<p class="small">
  <strong>Comparison Analysis.</strong> My manual and automatic 
  methods select different inlier sets, so the estimated homographies favor different regions. 
  For example, in the physics building example, manual selection emphasized roof features, yielding a well-aligned (but slightly soft) roof, while 
  the left green tree misaligns and blurs. The automatic method favored strong, repeatable features on the tree, aligning it sharply but leaving roof details slightly misregistered. 
  In short, each method’s inlier distribution biases the mosaic toward the areas that the respective method's inliers dominate.
</p>

</section>

  <footer class="small">
    <p>Notes: Normalized DLT + RANSAC for robust H; inverse warping (NN & Bilinear); feathered alpha for blending</p>
  </footer>

</body>
</html>
